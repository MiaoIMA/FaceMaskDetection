{"ast":null,"code":"/**\n * @license\n * Copyright 2023 CodeSmith LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport { image, serialization, tidy } from '@tensorflow/tfjs-core';\nimport { getExactlyOneTensor, getExactlyOneShape } from '../../utils/types_utils';\nimport { ValueError } from '../../errors';\nimport { BaseRandomLayer } from '../../engine/base_random_layer';\nimport { randomUniform } from '@tensorflow/tfjs-core';\nconst INTERPOLATION_KEYS = ['bilinear', 'nearest'];\nexport const INTERPOLATION_METHODS = new Set(INTERPOLATION_KEYS);\n/**\n * Preprocessing Layer with randomly varies image during training\n *\n * This layer randomly adjusts the width of a batch of images of a\n * batch of images by a random factor.\n *\n * The input should be a 3D (unbatched) or\n * 4D (batched) tensor in the `\"channels_last\"` image data format. Input pixel\n * values can be of any range (e.g. `[0., 1.)` or `[0, 255]`) and of interger\n * or floating point dtype. By default, the layer will output floats.\n *\n * tf methods implemented in tfjs: 'bilinear', 'nearest',\n * tf methods unimplemented in tfjs: 'bicubic', 'area', 'lanczos3', 'lanczos5',\n *                                   'gaussian', 'mitchellcubic'\n *\n */\nclass RandomWidth extends BaseRandomLayer {\n  constructor(args) {\n    super(args);\n    const {\n      factor,\n      interpolation = 'bilinear'\n    } = args;\n    this.factor = factor;\n    if (Array.isArray(this.factor) && this.factor.length === 2) {\n      this.widthLower = this.factor[0];\n      this.widthUpper = this.factor[1];\n    } else if (!Array.isArray(this.factor) && this.factor > 0) {\n      this.widthLower = -this.factor;\n      this.widthUpper = this.factor;\n    } else {\n      throw new ValueError(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);\n    }\n    if (this.widthLower < -1.0 || this.widthUpper < -1.0) {\n      throw new ValueError(`factor must have values larger than -1. Got: ${this.factor}`);\n    }\n    if (this.widthUpper < this.widthLower) {\n      throw new ValueError(`factor cannot have upper bound less than lower bound.\n        Got upper bound: ${this.widthUpper}.\n        Got lower bound: ${this.widthLower}\n      `);\n    }\n    if (interpolation) {\n      if (INTERPOLATION_METHODS.has(interpolation)) {\n        this.interpolation = interpolation;\n      } else {\n        throw new ValueError(`Invalid interpolation parameter: ${interpolation} is not implemented`);\n      }\n    }\n  }\n  getConfig() {\n    const config = {\n      'factor': this.factor,\n      'interpolation': this.interpolation\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n  computeOutputShape(inputShape) {\n    inputShape = getExactlyOneShape(inputShape);\n    const numChannels = inputShape[2];\n    return [this.imgHeight, -1, numChannels];\n  }\n  call(inputs, kwargs) {\n    return tidy(() => {\n      const input = getExactlyOneTensor(inputs);\n      this.imgHeight = input.shape[input.shape.length - 3];\n      const imgWidth = input.shape[input.shape.length - 2];\n      this.widthFactor = randomUniform([1], 1.0 + this.widthLower, 1.0 + this.widthUpper, 'float32', this.randomGenerator.next());\n      let adjustedWidth = this.widthFactor.dataSync()[0] * imgWidth;\n      adjustedWidth = Math.round(adjustedWidth);\n      const size = [this.imgHeight, adjustedWidth];\n      switch (this.interpolation) {\n        case 'bilinear':\n          return image.resizeBilinear(inputs, size);\n        case 'nearest':\n          return image.resizeNearestNeighbor(inputs, size);\n        default:\n          throw new Error(`Interpolation is ${this.interpolation}\n          but only ${[...INTERPOLATION_METHODS]} are supported`);\n      }\n    });\n  }\n}\n/** @nocollapse */\nRandomWidth.className = 'RandomWidth';\nexport { RandomWidth };\nserialization.registerClass(RandomWidth);","map":{"version":3,"sources":["../../../../../../../tfjs-layers/src/layers/preprocessing/random_width.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2023 CodeSmith LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\nimport { image, Rank, serialization, Tensor, tidy } from '@tensorflow/tfjs-core';\nimport { getExactlyOneTensor, getExactlyOneShape } from '../../utils/types_utils';\nimport { Shape } from '../../keras_format/common';\nimport { Kwargs } from '../../types';\nimport { ValueError } from '../../errors';\nimport { BaseRandomLayerArgs, BaseRandomLayer } from '../../engine/base_random_layer';\nimport { randomUniform } from '@tensorflow/tfjs-core';\n\nexport declare interface RandomWidthArgs extends BaseRandomLayerArgs {\n   factor: number | [number, number];\n   interpolation?: InterpolationType; // default = 'bilinear';\n   seed?: number; // default = null;\n   autoVectorize?: boolean;\n}\n\nconst INTERPOLATION_KEYS = ['bilinear', 'nearest'] as const;\nexport const INTERPOLATION_METHODS = new Set(INTERPOLATION_KEYS);\ntype InterpolationType = typeof INTERPOLATION_KEYS[number];\n\n/**\n * Preprocessing Layer with randomly varies image during training\n *\n * This layer randomly adjusts the width of a batch of images of a\n * batch of images by a random factor.\n *\n * The input should be a 3D (unbatched) or\n * 4D (batched) tensor in the `\"channels_last\"` image data format. Input pixel\n * values can be of any range (e.g. `[0., 1.)` or `[0, 255]`) and of interger\n * or floating point dtype. By default, the layer will output floats.\n *\n * tf methods implemented in tfjs: 'bilinear', 'nearest',\n * tf methods unimplemented in tfjs: 'bicubic', 'area', 'lanczos3', 'lanczos5',\n *                                   'gaussian', 'mitchellcubic'\n *\n */\n\nexport class RandomWidth extends BaseRandomLayer {\n  /** @nocollapse */\n  static override className = 'RandomWidth';\n  private readonly factor: number | [number, number];\n  private readonly interpolation?: InterpolationType;  // defualt = 'bilinear\n  private widthLower: number;\n  private widthUpper: number;\n  private imgHeight: number;\n  private widthFactor: Tensor<Rank.R1>;\n\n  constructor(args: RandomWidthArgs) {\n    super(args);\n    const {factor, interpolation = 'bilinear'} = args;\n\n    this.factor = factor;\n\n    if (Array.isArray(this.factor) && this.factor.length === 2) {\n      this.widthLower = this.factor[0];\n      this.widthUpper = this.factor[1];\n    } else if (!Array.isArray(this.factor) && this.factor > 0){\n      this.widthLower = -this.factor;\n      this.widthUpper = this.factor;\n    } else {\n      throw new ValueError(\n        `Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`\n      );\n    }\n    if (this.widthLower < -1.0 || this.widthUpper < -1.0) {\n      throw new ValueError(\n        `factor must have values larger than -1. Got: ${this.factor}`\n      );\n    }\n\n    if (this.widthUpper < this.widthLower) {\n      throw new ValueError(\n        `factor cannot have upper bound less than lower bound.\n        Got upper bound: ${this.widthUpper}.\n        Got lower bound: ${this.widthLower}\n      `);\n    }\n\n    if (interpolation) {\n      if (INTERPOLATION_METHODS.has(interpolation)) {\n        this.interpolation = interpolation;\n      } else {\n        throw new ValueError(`Invalid interpolation parameter: ${\n            interpolation} is not implemented`);\n      }\n    } \n  }\n\n  override getConfig(): serialization.ConfigDict {\n    const config: serialization.ConfigDict = {\n      'factor': this.factor,\n      'interpolation': this.interpolation,\n    };\n\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n\n  override computeOutputShape(inputShape: Shape|Shape[]): Shape|Shape[] {\n    inputShape = getExactlyOneShape(inputShape);\n    const numChannels = inputShape[2];\n    return [this.imgHeight, -1, numChannels];\n  }\n\n  override call(inputs: Tensor<Rank.R3>|Tensor<Rank.R4>,\n    kwargs: Kwargs): Tensor[]|Tensor {\n\n    return tidy(() => {\n      const input = getExactlyOneTensor(inputs);\n      this.imgHeight = input.shape[input.shape.length - 3];\n      const imgWidth = input.shape[input.shape.length - 2];\n\n      this.widthFactor = randomUniform([1],\n        (1.0 + this.widthLower), (1.0 + this.widthUpper),\n        'float32', this.randomGenerator.next()\n      );\n\n      let adjustedWidth = this.widthFactor.dataSync()[0] * imgWidth;\n      adjustedWidth = Math.round(adjustedWidth);\n\n      const size:[number, number] = [this.imgHeight, adjustedWidth];\n\n      switch (this.interpolation) {\n        case 'bilinear':\n          return image.resizeBilinear(inputs, size);\n        case 'nearest':\n          return image.resizeNearestNeighbor(inputs, size);\n        default:\n          throw new Error(`Interpolation is ${this.interpolation}\n          but only ${[...INTERPOLATION_METHODS]} are supported`);\n      }\n    });\n  }\n}\n\nserialization.registerClass(RandomWidth);\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}